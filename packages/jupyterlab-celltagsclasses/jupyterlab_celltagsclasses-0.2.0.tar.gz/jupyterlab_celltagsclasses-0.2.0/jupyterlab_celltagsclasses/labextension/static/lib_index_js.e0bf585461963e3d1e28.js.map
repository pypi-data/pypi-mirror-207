{"version":3,"file":"lib_index_js.e0bf585461963e3d1e28.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAgB;AAC/B;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8EAA8E;AACzH;AACA;AACA,sEAAsE,mBAAmB;AACzF;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,mBAAmB;AAC7F;AACA,iCAAiC;AACjC;AACA,4EAA4E,mBAAmB;AAC/F;AACA,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,0EAA0E,mBAAmB;AAC7F;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,4EAA4E,mBAAmB;AAC/F;AACA;AACA,6BAA6B;AAC7B;AACA,qBAAqB;AACrB,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,iEAAe,MAAM,EAAC","sources":["webpack://jupyterlab-celltagsclasses/./lib/index.js"],"sourcesContent":["/*\n * for attaching keybindings later on, see\n * https://towardsdatascience.com/how-to-customize-jupyterlab-keyboard-shortcuts-72321f73753d\n */\nimport { INotebookTracker } from '@jupyterlab/notebook';\n/**\n * Initialization data for the jupyterlab-celltagsclasses extension.\n */\nconst plugin = {\n    id: 'jupyterlab-celltagsclasses:plugin',\n    autoStart: true,\n    requires: [INotebookTracker],\n    activate: (app, notebookTracker) => {\n        console.log('extension jupyterlab-celltagsclasses is activating');\n        const class_for_tag = (tag) => `cell-tag-${tag}`;\n        notebookTracker.widgetAdded.connect((_, panel) => {\n            const notebookModel = panel.content.model;\n            if (notebookModel === null) {\n                return;\n            }\n            notebookModel.cells.changed.connect((cellList, change) => {\n                if (change.type !== 'add') {\n                    return;\n                }\n                change.newValues.forEach(cellModel => {\n                    var _a, _b;\n                    // compute widgets attached to cellModel\n                    const cellWidgets = (_a = notebookTracker.currentWidget) === null || _a === void 0 ? void 0 : _a.content.widgets.filter((cell, index) => cell.model.id === cellModel.id);\n                    if (cellWidgets === undefined || (cellWidgets === null || cellWidgets === void 0 ? void 0 : cellWidgets.length) === 0) {\n                        console.warn('could not find cell widget for cell model', cellModel);\n                        return;\n                    }\n                    console.debug(`found ${cellWidgets === null || cellWidgets === void 0 ? void 0 : cellWidgets.length} cell widgets`, cellWidgets[0]);\n                    // add classes for pre-existing tags\n                    (_b = cellModel.getMetadata('tags')) === null || _b === void 0 ? void 0 : _b.forEach((tag) => cellWidgets === null || cellWidgets === void 0 ? void 0 : cellWidgets.forEach(cellWidget => {\n                        console.debug(`adding initial class for tag ${class_for_tag(tag)}`);\n                        cellWidget.addClass(class_for_tag(tag));\n                    }));\n                    // react to changes in tags\n                    cellModel.metadataChanged.connect((sender, change) => {\n                        console.debug('metadata changed', sender, change);\n                        if (change.key !== 'tags') {\n                            // console.debug(\"ignoring non-tags metadata change\")\n                            return;\n                        }\n                        // does not seem useful to recompute this\n                        // const cellWidgets = notebookTracker.currentWidget?.content.widgets.filter(\n                        //   (cell: Cell, index: number) => (cell.model.id === cellModel.id)\n                        // )\n                        if (change.type === 'change') {\n                            console.debug('change', change, change.newValue);\n                            // compute difference between old and new tags\n                            const oldTags = change.oldValue;\n                            const newTags = change.newValue;\n                            const addedTags = newTags.filter(tag => !oldTags.includes(tag));\n                            const removedTags = oldTags.filter(tag => !newTags.includes(tag));\n                            console.log('addedTags', addedTags);\n                            console.log('removedTags', removedTags);\n                            cellWidgets.forEach(cellWidget => {\n                                addedTags.forEach(tag => {\n                                    console.debug(`adding class for tag ${class_for_tag(tag)}`);\n                                    cellWidget.addClass(class_for_tag(tag));\n                                });\n                                removedTags.forEach(tag => {\n                                    console.debug(`removing class for tag ${class_for_tag(tag)}`);\n                                    cellWidget.removeClass(class_for_tag(tag));\n                                });\n                            });\n                        }\n                        else if (change.type === 'add') {\n                            console.log('add', change, change.newValue);\n                            cellWidgets.forEach(cellWidget => {\n                                for (const tag of change.newValue) {\n                                    console.debug(`adding class for tag ${class_for_tag(tag)}`);\n                                    cellWidget.addClass(class_for_tag(tag));\n                                }\n                            });\n                        }\n                        else if (change.type === 'remove') {\n                            console.log('remove', change, change.newValue);\n                            cellWidgets.forEach(cellWidget => {\n                                for (const tag of change.newValue) {\n                                    console.debug(`removing class for tag ${class_for_tag(tag)}`);\n                                    cellWidget.removeClass(class_for_tag(tag));\n                                }\n                            });\n                        }\n                    });\n                });\n            });\n        });\n    }\n};\nexport default plugin;\n"],"names":[],"sourceRoot":""}