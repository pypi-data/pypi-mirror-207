# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_structs.ipynb.

# %% auto 0
__all__ = ['User', 'UserManager', 'NodeManager', 'Node', 'Question', 'Proposal', 'LogicGate', 'Connection']

# %% ../nbs/00_structs.ipynb 3
import datetime

# %% ../nbs/00_structs.ipynb 5
class User:

    """
    The `User` class represents a user in the network.
    
        - `name`: The name of the user
        - `password`: The password of the user
        - `email`: The email of the user
        - `user_manager`: The `UserManager` for the session
    """

    def __init__(self, name, password, email, user_manager):

        # Move to auth provider
        self.name = name
        self.password = password
        self.email = email
        self.id = len(user_manager.users)

        # How to serialize?
        self.type = "user"
        self.questions = []
        self.proposals = []
        self.logic_gates = []
        self.time_created = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def create_question(self, description, node_manager):

        author = (self.id, self.name)

        # PROPOSAL 1: Create Question object outside of class method and pass id to user.create_question.
        question = Question(description, author, node_manager)
        node_manager.add_node(question)

        # PROPOSAL 1: question.id --> question_id
        self.questions.append(question.id)
        
        return question

    def create_proposal(self, description, attached_questions, node_manager):

        author = (self.id, self.name)

        # PROPOSAL: Create Proposal object outside of User class method and pass the id to user.create_proposal.
        proposal = Proposal(description,author, attached_questions, node_manager)
        node_manager.add_node(proposal)

        # PROPOSAL: proposal.id --> proposal_id
        self.proposals.append(proposal.id)
        
        for question_id in attached_questions:

            # PROPOSAL: Create Connection objects outside of User class method. 
            # This logic doesn't need to be run here.
            connection = Connection(question_id, proposal.id, node_manager)
            node_manager.add_connection(connection)

        return proposal

    def create_logic_gate(self, premises, gate_type, assertions, node_manager):

        author = (self.id, self.name)

        # PROPOSAL: Create LogicGate object outside of User class method and pass the id to user.create_logic_gate.
        logic_gate = LogicGate(gate_type, premises,  assertions, author, node_manager)
        node_manager.add_node(logic_gate)

        # PROPOSAL: Create Proposal object outside of User class method and pass the id to user.create_proposal.
        self.logic_gates.append(logic_gate.id)
        
        for premise_id in premises:
            connection = Connection(premise_id, logic_gate.id, node_manager)
            premise = node_manager.get_node(premise_id)
            premise.premise_of.append(logic_gate.id)
            node_manager.add_connection(connection)

        for assertion_id in assertions.keys():
            connection = Connection(logic_gate.id, assertion_id, node_manager)
            node_manager.add_connection(connection)
        return logic_gate
    
    def vote(self, node_id, vote, node_manager):
        node = node_manager.get_node(node_id) 
        ### start new addition
        if vote == True and self.id in node.agree_users:
            print("User has already voted on this proposal.")
            return
        elif vote == False and self.id in node.disagree_users:
            print("User has already voted on this proposal.")
            return
        elif vote == True and self.id in node.disagree_users:
            node.agree_users.append(self.id)
            node.disagree_users.remove(self.id)
            print("Changing vote to APPROVE.")
        elif vote == False and self.id in node.agree_users:
            node.disagree_users.append(self.id)
            node.agree_users.remove(self.id)
            print("Changing vote to REJECT.")
            
        ### end new addition
        #if self.id in node.agree_users or self.id in node.disagree_users: # Check if user has already voted
         #   print("User has already voted on this proposal.") 
         #   return

        elif vote ==True: 
            node.agree_users.append(self.id) # Add user to agree list
        elif vote == False:
            node.disagree_users.append(self.id) # Add user to disagree list

        old_alignment_status = node.alignment_status # Store old alignment status
        total_votes = len(node.agree_users) + len(node.disagree_users) # Calculate total votes
        if len(node.agree_users) > (total_votes / 2): # Check if agree votes are greater than half of total votes
            node.alignment_status = True # Set alignment status to true
            print("Proposal has been approved.")
        else:
            node.alignment_status = False # Set alignment status to false
            print("Proposal has been rejected.")
        if node.type == "proposal":
            node_manager.evaluate_proposal(node_id)
            node_manager.propogate_change(node_id)
        elif node.type == "logic_gate":
            node_manager.check_gate_status(node_id)
            node_manager.propogate_change(node_id)
        #if old_alignment_status != node.alignment_status: # Check if alignment status has changed
            #propogate alignment status change
         #   node_manager.propogate_change(node_id)

# %% ../nbs/00_structs.ipynb 6
class UserManager:

    """
    UserManager handles the users in the network.

        - `users` (dict): A dictionary mapping user ids to users in the network.
    """

    def __init__(self):
        self.users = {}

    # PROPOSAL: Create User object outside of UserManager class method and pass the id to user_manager.add_user.
    def add_user(self, name, password, email):
        user = User(name, password, email,self)
        self.users[user.id] = user
        assert user.id in self.users
        print(f"User {user.id} has been created and added to UserManager.users.")
        return user

    def get_user(self, user_id):
        return self.users[user_id]

    def remove_user(self, user_id):
        del self.users[user_id]

# %% ../nbs/00_structs.ipynb 16
# Proposal: Create Graph class to handle the network graph.
# Proposal: Create AlignmentMonitor class to watch and report on alignment status changes.

class NodeManager:

    """
    NodeManager handles the nodes in the network.
    The current implementation is unique to each session, and does not handle any database communication.

        - `nodes` (dict): A dictionary mapping node ids to nodes in the network.
        - `connections` (dict): A dictionary mapping edge connection ids to edge connections in the network.
    """

    def __init__(self):
        self.nodes = {}
        self.connections = {}

    def add_node(self, node):
        self.nodes[node.id] = node

    def get_node(self, node_id):
        return self.nodes[node_id]

    def remove_node(self, node_id):
        del self.nodes[node_id]

    # PROPOSAL: This operation does not seem like a NodeManager task. Move to Graph class.
    def add_connection(self, connection):
        # TODO: This means every edge connection is stored twice. Is there a better way to do this?
        # PROPOSAL: We should be storing graph information like how edges and nodes are related in one of:
            # A) an adjacency list,
            # B) an adjacency matrix, or
            # C) an edge list.
        # QUESTION: Which one?
        self.connections[connection.id] = connection

    # PROPOSAL: This operation does not seem like a NodeManager task. Move to Graph class.
    def get_connection(self, connection_id):
        return self.connections[connection_id]

    # PROPOSAL: This operation does not seem like a NodeManager task. Move to Graph class.
    def remove_connection(self, connection_id):
        del self.connections[connection_id]

    # PROPOSAL: This algorithm does not seem like a NodeManager task. Move to AlignmentMonitor class.
    def evaluate_proposal(self, proposal_id): # Is the proposal aligned? return True if status changed
        proposal = self.get_node(proposal_id)
        prev_alignment_status = proposal.alignment_status
        asserts = proposal.attached_logic.values()
        if len(asserts) == 0:
            total_votes = len(proposal.agree_users) + len(proposal.disagree_users) # Calculate total votes
            if len(proposal.agree_users) > (total_votes / 2): # Check if agree votes are greater than half of total votes
                proposal.alignment_status = True # Set alignment status to true
                print("Proposal has been approved.")
            else:
                proposal.alignment_status = False # Set alignment status to false
                print("Proposal has been rejected.")
            return
        if  True in asserts and  False in asserts:
            return "Error - Proposal has both true and false assertions"
        elif True in asserts:
            proposal.alignment_status = True
        elif False in asserts:
            proposal.alignment_status = False
        return prev_alignment_status != proposal.alignment_status

    # PROPOSAL: This algorithm does not seem like a NodeManager task. Move to AlignmentMonitor class.
    def evaluate_gate(self, gate_id): # Is the logic statisfied?
        gate = self.get_node(gate_id)
        alignment_statuses=[]
        for premise in gate.premises:
            alignment_statuses.append(self.get_node(premise).alignment_status)
        if gate.gate_type == "AND":
            return all(alignment_statuses)
        elif gate.gate_type == "OR":
            return any(alignment_statuses)
        elif gate.gate_type == "NAND":
            return not all(alignment_statuses)
        elif gate.gate_type == "XOR":
            return sum(alignment_statuses) == 1
        else:
            raise ValueError("Invalid gate type")
        
    # PROPOSAL: This algorithm does not seem like a NodeManager task. Move to AlignmentMonitor class.
    def check_gate_status(self, gate_id): # Set the gate active status and return true if it has changed
        gate = self.get_node(gate_id) # Get gate instance
        prev_status = gate.gate_active # Store current gate status
        gate_result = self.evaluate_gate(gate_id) # Is logic statisfied?
        if gate_result == True and gate.alignment_status == True: # Check if gate is satisfied and aligned--> If so, gate is active
            gate.gate_active = True # Set gate status to true
        else:
            gate.gate_active = False # Set gate status to false
        if prev_status != gate.gate_active:  # Check if gate status has changed
            return True # Return true if gate status has changed
        else:
            return False # Return false if gate status has not changed
    
    # PROPOSAL: This algorithm does not seem like a NodeManager task. 
        # TODO: It is related, but does not belong to the AlignmentMonitor class.
        # Instead, it seems like a monitor should trigger it on an event. Maybe a lambda function in the Graph class?
    def propogate_change(self,node_id):
        node = self.get_node(node_id)
        if node.type == "proposal": # If node is a proposal
            changed=self.evaluate_proposal(node_id) # Evaluate proposal
            for logic_gate_id in node.premise_of: # For each logic gate attached to the proposal
                if self.check_gate_status(logic_gate_id): # Check if gate status has changed
                    self.propogate_change(logic_gate_id) # Propogate change to logic gate
        elif node.type == "logic_gate": # If node is a logic gate
            for assertion_id,assertion_value in zip(node.assertions.keys(), node.assertions.values()): # For each assertion attached to the logic gate
                temp_assertion = self.get_node(assertion_id) # Get assertion instance
                if node.gate_active == True: # If gate is active
                    temp_assertion.attached_logic[node.id] = assertion_value # Update assertion's attached logic
                    self.propogate_change(assertion_id) # Propogate change to assertion
                if node.gate_active == False: # If assertion is false delete it from the assertion's attached logic
                    del temp_assertion.attached_logic[node.id]
                    self.propogate_change(assertion_id)
        
        else:
            raise ValueError("Invalid node type")

# %% ../nbs/00_structs.ipynb 17
class Node:

    """
    The Node class is the base class for all nodes in the network. 

        - `id`: The unique identifier for the node
        - `time_created`: The time the node was created
        - `type`: The type of node (e.g. Question, Proposal, etc.)
        - `author`: The id of the author of the node
    """

    def __init__(self, node_type, author, node_manager):

        self.id = len(node_manager.nodes)
        self.time_created = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.type = node_type
        self.author = author

        node_manager.add_node(self)

# %% ../nbs/00_structs.ipynb 19
class Question(Node):

    """
    The Question class is a subclass of the Node class. A question asks who, how, why, what or where about a potential truth claim.

        - `description`: The description of the question
        - `author`: The id of the author of the question
        - `node_manager`: The node manager instance
    """

    def __init__(self, description, author, node_manager):

        super().__init__("question", author, node_manager)
        self.description = description
        self.alignment_status = "NA"

# %% ../nbs/00_structs.ipynb 24
class Proposal(Node):

    """
    The Proposal class is a subclass of the Node class. A proposal is a truth claim.

        - `description`: The description of the proposal
        - `author`: The id of the author of the proposal
        - `attached_questions`: The ids of the questions attached to the proposal
        - `node_manager`: The node manager instance
    """

    def __init__(self, description, author, attached_questions, node_manager):

        super().__init__("proposal", author, node_manager)
        self.description = description
        self.attached_questions = attached_questions
        self.agree_users = []         
        self.disagree_users = []
        self.alignment_status = False # Converesation to have: Rules for measuring alignment statii...
        self.attached_logic = {} # dict of logic gate ids and assertions.
        self.premise_of = [] # list of logic gates for which this is a premise

# %% ../nbs/00_structs.ipynb 29
class LogicGate(Node):

    """
    A logic gate is a boolean operator that evaluates the alignment statuses of its premises and returns a boolean value.

        - `gate_type`: The type of logic gate (e.g. AND, OR, NAND, XOR)
        - `premises`: The ids of the premises attached to the logic gate
        - `assertions`: The assertions attached to the logic gate
        - `author`: The id of the author of the logic gate
        - `node_manager`: The node manager instance
    """

    def __init__(self, gate_type, premises, assertions, author, node_manager):

        super().__init__("logic_gate", author, node_manager)
        
        self.gate_type = gate_type
        self.premises = premises

        # QUESTION: This is never used. What do assertions members of a LogicEdge do?
        # PROPOSITION: If there are no assertions, then the logic gate is a no-op.
        self.assertions = assertions

        self.gate_active = False
        self.alignment_status = "NA"
        self.agree_users = []
        self.disagree_users = []
        self.attached_logic = []

    def evaluate_gate(self, node_manager): # moved to node_manager

        alignment_statuses = [
            node_manager.get_node(premise).alignment_status
            for premise in self.premises
        ]

        if self.gate_type == "AND":
            return all(alignment_statuses)

        elif self.gate_type == "OR":
            return any(alignment_statuses)

        elif self.gate_type == "NAND":
            return not all(alignment_statuses)

        elif self.gate_type == "XOR":
            return sum(alignment_statuses) == 1

        else:
            raise ValueError("Invalid gate type")

# %% ../nbs/00_structs.ipynb 35
class Connection:

    """
    The Connection class represents a connection between two nodes in the network.

        - `source`: The unique identifier from the source node
        - `target`: The unique identifier from the target node
        - `node_manager`: The node manager instance
    """

    def __init__(self, source, target, node_manager):
        self.id = len(node_manager.connections)
        self.time_created = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.type = "connection"
        self.source = source
        self.target = target
